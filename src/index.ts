import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import utf8 from 'utf8';
import StreamZip from 'node-stream-zip';
import prettyBytes from 'pretty-bytes';
// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  // eslint-disable-line global-require
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 850,
    width: 1400,
    webPreferences: {
      nodeIntegration: false, // is default value after Electron v5
      contextIsolation: true, // protect against prototype pollution
      enableRemoteModule: false, // turn off remote
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY, // use a preload script
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
//   callback({ responseHeaders: Object.assign({
//       "Content-Security-Policy": [ "default-src 'self'" ]
//     }, details.responseHeaders)});
// });

ipcMain.on('click', () => console.log('do something'));

interface Participant {
  name: string;
}

interface Photo {
  uri: string; // zip path of photo
  creation_timestamp: number;
}

interface Video {
  uri: string;
  creation_timestamp: number;
  thumbnail: {
    uri: string;
  };
}

interface Sticker {
  uri: string;
}

interface Gif {
  uri: string;
}

export interface Message {
  sender_name: string;
  timestamp_ms: number;
  content: string;
  type: string;
  is_unsent: boolean;
  photos?: Photo[];
  videos?: Video[];
  sticker?: Sticker;
  gifs?: Gif[];
}

interface JSONMessagesRaw {
  title: string;
  is_still_participant: boolean;
  thread_type: string;
  thread_path: string;
  participants: Participant[];
  messages: Message[];
}

export interface JSONMessages extends JSONMessagesRaw {
  messageCount: number;
  id: string;
  last_msg_timestamp: number;
  first_msg_timestamp: number;
}

const allConversations: { [key in string]: JSONMessages } = {};

export interface BasicInfo {
  title: string;
  // participants: Participant[];
  messageCount: number;
  id: string;
}

// let summary: { [key in string]: BasicInfo } = {};

const timeLog = (s: string) => console.log(`[${new Date().toLocaleTimeString()}] ${s}`);

ipcMain.on('get-messages', async (event, conversation_id) => {
  // console.log('XD:', xd);
  // event.reply('user-messages')
  if (allConversations[conversation_id]) {
    event.reply('user-messages', allConversations[conversation_id]);
  } else {
    console.log('Messages for ', conversation_id, ' not found!');
  }
});

ipcMain.on('app:on-fs-dialog-open', async (event) => {
  const { filePaths, canceled } = await dialog.showOpenDialog({
    properties: ['multiSelections'],
    filters: [{ name: 'Facebook backup zips', extensions: ['zip'] }],
  });
  if (canceled) {
    return [];
  }

  event.reply('users-progress', -1);

  timeLog('Initial pass');

  const filesInfo = await Promise.all(
    filePaths.map(async (file) => {
      const zip = new StreamZip.async({ file });
      const allFiles = await zip.entries();
      const msgFileRegex = new RegExp(`messages/inbox/[a-z0-9-_]+/message_\\d+\\.json`);
      const messageFiles = Object.values(allFiles).filter((f) => msgFileRegex.test(f.name));
      const messageFileNames = messageFiles.map((f) => f.name);
      const totalMessageSizes = messageFiles.reduce((sum, f) => sum + f.size, 0);

      await zip.close();
      return { name: file, messageFiles: messageFileNames, totalMessageSizes };
    })
  );

  const totalFileSizes = filesInfo.reduce((sum, fi) => sum + fi.totalMessageSizes, 0);
  timeLog(
    `Initial pass done, total files size to process: ${prettyBytes(totalFileSizes, {
      minimumFractionDigits: 1,
    })}`
  );

  event.reply('users-progress', 0);

  timeLog('Parse pass');

  const possibleOwners: { [key in string]: number } = {};
  let doneBytes = 0;
  let lastDoneBytes = 0;

  for (const file of filesInfo) {
    const zip = new StreamZip.async({ file: file.name, });

    for (const f of file.messageFiles) {
      const msg_data = await zip.entryData(f);
      const entryData = await zip.entry(f);
      const splittedFileName = f.split('/');
      const user = splittedFileName[splittedFileName.length - 2];
      const msg_parsed = JSON.parse(msg_data.toString()) as JSONMessagesRaw;
      const { messages: msg_messages, ...msg_details } = msg_parsed;
      const msg_fixed: JSONMessages = {
        ...msg_details,
        title: msg_details.title ? utf8.decode(msg_details.title) : msg_details.title,
        participants: msg_details.participants
          ? msg_details.participants.map((p) => ({ ...p, name: utf8.decode(p.name) }))
          : msg_details.participants,
        messages: msg_messages.map((msg) => ({
          ...msg,
          sender_name: msg.sender_name ? utf8.decode(msg.sender_name) : msg.sender_name,
          content: msg.content ? utf8.decode(msg.content) : msg.content,
        })),
        id: user,
        messageCount: 0,
        last_msg_timestamp: Math.max(...msg_messages.map((m) => m.timestamp_ms)),
        first_msg_timestamp: Math.min(...msg_messages.map((m) => m.timestamp_ms)),
      };
      if (allConversations[user]) {
        allConversations[user].messages = allConversations[user].messages.concat(
          msg_fixed.messages
        );
        allConversations[user].messageCount += msg_fixed.messages.length;

        if (allConversations[user].last_msg_timestamp < msg_fixed.last_msg_timestamp) {
          allConversations[user].last_msg_timestamp = msg_fixed.last_msg_timestamp;
        }

        if (allConversations[user].first_msg_timestamp > msg_fixed.first_msg_timestamp) {
          allConversations[user].first_msg_timestamp = msg_fixed.first_msg_timestamp;
        }
      } else {
        allConversations[user] = msg_fixed;
        allConversations[user].messageCount = msg_fixed.messages.length;
        const possibleOwner = msg_fixed.participants.filter(
          (p) => p.name !== msg_fixed.title
        );
        if (possibleOwner.length === 1) {
          if (!possibleOwners[possibleOwner[0].name]) {
            possibleOwners[possibleOwner[0].name] = 0;
          }
          possibleOwners[possibleOwner[0].name] += 1;
        }
      }

      doneBytes += entryData.size;

      if ((doneBytes - lastDoneBytes) >= totalFileSizes/26.5 || doneBytes === totalFileSizes) {
        lastDoneBytes = doneBytes;
        console.log(`${Math.round(doneBytes/totalFileSizes*1000)/10}% done`);
        event.reply('users-progress', doneBytes/totalFileSizes*100);
      }
    }

    await zip.close();
  }

  timeLog('Parse pass done');
  timeLog('Sort pass');

  for (const user in allConversations) {
    allConversations[user].messages.sort((a, b) => a.timestamp_ms - b.timestamp_ms);
  }

  timeLog('Sort pass done');

  if (Object.keys(possibleOwners).length === 0) {
    console.error('Did not found any possible owner!');
  } else {
    const owner = Object.keys(possibleOwners).sort(
      (a, b) => possibleOwners[b] - possibleOwners[a]
    )[0];
    event.reply('owner', owner);
  }

  // event.reply('users-progress', 0.5);
  console.log('sending', new Date());
  event.reply('users', allConversations);
  console.log('emitted', new Date());
});
